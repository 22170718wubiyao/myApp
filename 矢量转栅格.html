<!DOCTYPE html>
<html>

<head>
    <title>
        矢量数据栅格化
    </title>
    <style>
         .btn {
            margin-left: 20px;
            margin-top: 0px;
            border-color: grey;
            border-radius: 3px;
            background-color: white;
            /* width: flex; */
            height: 25px;
            font-size: 13px;
        }
        .result1 {
            margin-left: 10px;
            border: 1px solid rgb(80, 50, 252);
            width: 200px;
            height: 250px;
            overflow: auto;
            margin-top: 5px;
            padding: 10px;
            font-family: 宋体;
            font-size: 15px;
        }
        .result2 {
            margin-left: 10px;
            border: 1px solid rgb(80, 50, 252);
            width: 300px;
            height: 250px;
            overflow: auto;
            margin-top: 5px;
            padding: 10px;
            font-family: 宋体;
            font-size: 15px;
        }
        .row {
            display: flex;
            flex-direction: row;
        }
        .column {
            display: flex;
            flex-direction: column;
        }
        .nav{
        color:red;
        border-width:3px;  
        /*border-style: solid;*/
        border-left-style:solid;
        border-top-style:dotted;
        border-right-style: dashed;
        border-bottom-style: double;
        border-left-color: red;
        border-top-color: green;
        border-right-color: blue;
        border-bottom-color: purple;
    
       /* border-color: blue;*/
        width: 100px;
        height: 40px;
        background-color: white;
    
    }
    </style>
</head>

<body>
    
        
        <strong style="margin-left:5px;margin-top:10px;font-family:宋体;font-size:18px;">22170718 吴碧瑶</strong>
        <div style="font-size:15px;font-family:宋体;display:flex;flex-direction:row;margin-top:10px;" >
            
           <div>
                <strong>请选择需要构建的数据文件：</strong>
                <input id="File" type="file" multiple="mutifile" />
           </div>
           <div style="margin-left:-5%;">
                <button class="nav" type="button" onclick="get() ">构建多边形</button>
            </div>
            <div style="margin-left:2%;">
                <button class="nav" type="button" onclick="ClearCanvas() ">清除</button>
            </div>
        </div>
        
        
    </div>
    <div class="row" style="  width: 1250px;">
        <div class="column" style=" width: 350px;">
            <div style="margin-top:2vh;margin-left:2vw;font-size:15px;font-family:宋体;">原始多边形图像为：</div>
            <canvas id="canvas1" style="border:1px solid rgb(131, 32, 32);margin-top:1%;margin-left:2vw;"></canvas>
            <div style="margin-top:2vh;margin-left:2vw;font-size:15px;font-family:宋体;">矢量转栅格结果为：</div>
            <canvas id="canvas2" style="border:1px solid rgb(131, 32, 32);margin-top:1%;margin-left:2vw;"></canvas>
        </div>
       
        </div>

    <script>
        var canvas1 = document.getElementById('canvas1');
        var ctext1 = canvas1.getContext('2d');
        canvas1.width = 310;
        canvas1.height = 200;
        var canvas2 = document.getElementById('canvas2');
        var ctext2 = canvas2.getContext('2d');
        canvas2.width = 310;
        canvas2.height = 200;
        var times = 1.6;
        var Node = [];//结点表
        var allpoints = [];//存储所有的结点
        var NodeArc = [];//结点-弧段表
        var ArcNode = [];//弧段-结点表
        var ArcNodefinal = [];
        var PolygonArc = [];//多边形-弧段表
        var PolygonArcTemp = [];//临时多边形-弧段表用于存储点便于判断岛计算面积
        var ArcPoly = [];//弧段-多边形表
        var border = {};//外围多边形
        var island = [];
        var arcpolytemp = [];
        var arcpolyfinal = [];
        // 存储栅格数据的数组50*50，初始化其中的数值均为0
        var grid = new Array();
        for (var i = 0; i < 250; i++) {
            grid[i] = new Array();
            for (var j = 0; j < 250; j++) {
                grid[i][j] = 0;
            }
        }
        //读取文件
        function get() {
            var files = document.getElementById('File').files;
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                var reader = new FileReader();
                reader.readAsText(file);//以文本形式读取文件
                //成功读取
                reader.onload = function (e) {
                    record = this.result;//读取文件
                    draw(record);//绘制该文件中包含的内容，并构建结点表，结点弧段表，弧段结点表
                    drawpoint();
                    SortNodeArc();//将结点弧段表中的每个结点对应的弧段按角度的大小排序，以便构建左转算法
                    LeftTurnAlgorithm();
                    CreatePolygonArc();
                    judgeisland();
                    drawresult();
                    convertTogrid();
                }
            }
        }
        function fillgrid(j, i, value) {
            //对该行的所有像素填充
            for (; j >= 0; j--) {
                grid[i][j] += value;
            }
        }
        function convertTogrid() {
            //处理数据，创建结构其中包含所有边的左右多边形编号（含最外边的多边形），每条边的坐标点
            for (var i = 0; i < arcpolytemp.length; i++) {
                for (var j = 0; j < Node.length; j++) {
                    if (arcpolytemp[i].start == j) {
                        arcpolytemp[i].startpoint[0] = Node[j][0];
                        arcpolytemp[i].startpoint[1] = Node[j][1];
                    }
                    if (arcpolytemp[i].end == j) {
                        arcpolytemp[i].endpoint[0] = Node[j][0];
                        arcpolytemp[i].endpoint[1] = Node[j][1];
                    }
                }
            }
            for (var j = 0; j < ArcNode.length; j++) {
                for (var i = 0; i < arcpolytemp.length; i++) {
                    if (arcpolytemp[i].startpoint[0] == ArcNode[j].start[0] && arcpolytemp[i].startpoint[1] == ArcNode[j].start[1] &&
                        arcpolytemp[i].endpoint[0] == ArcNode[j].end[0] && arcpolytemp[i].endpoint[1] == ArcNode[j].end[1]) {
                        arcpolyfinal.push({
                            start: arcpolytemp[i].start,
                            end: arcpolytemp[i].end,
                            startpoint: arcpolytemp[i].startpoint,
                            endpoint: arcpolytemp[i].endpoint,
                            left: arcpolytemp[i].left,
                            right: arcpolytemp[i].right,
                            points: arcpolytemp[i].points,
                        });
                    }
                }
            }
            arcpolytemp = [];
            arcpolytemp = arcpolyfinal;
            for (var i = 0; i < arcpolytemp.length; i++) {
                for (var j = 0; j < ArcNode.length; j++) {
                    if (arcpolytemp[i].startpoint[0] == ArcNode[j].start[0] && arcpolytemp[i].startpoint[1] == ArcNode[j].start[1] &&
                        arcpolytemp[i].endpoint[0] == ArcNode[j].end[0] && arcpolytemp[i].endpoint[1] == ArcNode[j].end[1]) {
                        for (var k = 0; k < ArcNode[j].points.length; k++) {
                            arcpolytemp[i].points.push([
                                ArcNode[j].points[k][0],
                                ArcNode[j].points[k][1],
                            ]);
                        }
                    }
                    else if (arcpolytemp[i].startpoint[0] == ArcNode[j].end[0] && arcpolytemp[i].startpoint[1] == ArcNode[j].end[1] &&
                        arcpolytemp[i].endpoint[0] == ArcNode[j].start[0] && arcpolytemp[i].endpoint[1] == ArcNode[j].start[1]) {
                        for (var k = ArcNode[j].points.length - 1; k >= 0; k--) {
                            arcpolytemp[i].points.push([
                                ArcNode[j].points[k][0],
                                ArcNode[j].points[k][1]
                            ]);
                        }
                    }
                }
            }
            for (var i = 0; i < arcpolytemp.length; i++) {
                if (arcpolytemp[i].left == border.id) {
                    arcpolytemp[i].left = -1;
                }
                // 对最外围的多边形做特殊处理，其值为0
                if (arcpolytemp[i].right == border.id) {
                    arcpolytemp[i].right = -1;
                }
            }
            //将原本多边形排除掉最外界的多边形之后的其他多边形的多边形编号加以调整
            for (var i = 0; i < arcpolytemp.length; i++) {
                if (arcpolytemp[i].left > border.id) {
                    arcpolytemp[i].left = arcpolytemp[i].left - 1;
                }
                if (arcpolytemp[i].right > border.id) {
                    arcpolytemp[i].right = arcpolytemp[i].right - 1;
                }
            }
            // 先将X,Y点的坐标转换为栅格所在的行列号,小数部分采用截断的方式
            for (var i = 0; i < arcpolytemp.length; i++) {
                arcpolytemp[i].startpoint[0] = Math.trunc(arcpolytemp[i].startpoint[0]);
                arcpolytemp[i].startpoint[1] = Math.trunc(arcpolytemp[i].startpoint[1]);
                arcpolytemp[i].endpoint[0] = Math.trunc(arcpolytemp[i].endpoint[0]);
                arcpolytemp[i].endpoint[1] = Math.trunc(arcpolytemp[i].endpoint[1]);
                for (var j = 0; j < arcpolytemp[i].points.length; j++) {
                    arcpolytemp[i].points[j][0] = Math.trunc(arcpolytemp[i].points[j][0]);
                    arcpolytemp[i].points[j][1] = Math.trunc(arcpolytemp[i].points[j][1]);
                }
            }
            //依次扫描各边，判断当边界弧段上行时，该弧段与左图框之间栅格增加一个值（左多边形减去右多边形）
            // 当边界弧段下行时，该弧段与左图框之间的栅格增加一个值（右多边形编号减去左多边形编号）
            for (var i = 0; i < arcpolytemp.length; i++) {
                for (var j = 0; j < arcpolytemp[i].points.length - 1; j++) {
                    if (arcpolytemp[i].points[j][1] - arcpolytemp[i].points[j + 1][1] > 0) {//弧段下行
                        var value = (arcpolytemp[i].right + 1) - (arcpolytemp[i].left + 1);
                    }
                    else if (arcpolytemp[i].points[j][1] - arcpolytemp[i].points[j + 1][1] < 0) {//弧段上行
                        var value = (arcpolytemp[i].left + 1) - (arcpolytemp[i].right + 1);
                    }
                    else {
                        continue;
                    }
                    var startx = arcpolytemp[i].points[j][0];
                    var starty = arcpolytemp[i].points[j][1];
                    var endx = arcpolytemp[i].points[j + 1][0];
                    var endy = arcpolytemp[i].points[j + 1][1];
                    var dy = arcpolytemp[i].points[j + 1][1] - arcpolytemp[i].points[j][1];
                    var dx = arcpolytemp[i].points[j + 1][0] - arcpolytemp[i].points[j][0];
                    var max, xincre, yincre;
                    //判断斜率以判断下一个点的坐标，利用数值微分法
                    if (Math.abs(dx) > Math.abs(dy)) {
                        max = Math.abs(dx);//k属于-1到1的情况
                    }
                    else {
                        max = Math.abs(dy);//k<-1或者k>1
                    }
                    xincre = dx / max;
                    yincre = dy / max;
                    var A = endy - starty;
                    var B = startx - endx;
                    var C = endx * starty - startx * endy;
                    if (starty <= endy) {
                        for (var k = starty; k <= endy; k++) {
                            startx = parseInt((-B * k  -C) / A);
                            fillgrid(startx, k, value);
                        }
                    }
                    else {
                        for (var t = starty; t >= endy; t--) {
                     
                            startx = parseInt((-B * t -C) / A);
                            fillgrid(startx, t, value);
                        }
                    }
                }
            }
            // 根据得到的二维数组进行填充，若数值为0，则不予以填充，若数值非零则填充相应的颜色
            var color = ["yellow", "blue","orange","green", "pink",  "red","gray",  "lightblue", "black","lightgreen" ];
            for (var i = 0; i < grid.length; i++) {
                for (var j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] != 0) {
                        ctext2.beginPath();
                        ctext2.fillStyle = color[grid[i][j]];
                        ctext2.fillRect(j * times - 20, (canvas2.height - i * times) + 150, 1, 1);
                        ctext2.stroke();
                    }
                }
            }
        }
        function drawpoint() {
            for (var i = 0; i < Node.length; i++) {
                ctext1.beginPath();
                ctext1.fillStyle = "red";
                var x0 = Node[i][0] * times - 10;
                var y0 = (canvas1.height - Node[i][1]) * times + 40 + 1;
                ctext1.arc(x0, y0, 3, 0, Math.PI * 2, true);
                ctext1.fill();
                ctext1.font = "15px 宋体";
                var text = i + 1;
                text = "N" + text.toString();
                ctext1.fillStyle = "black";
                ctext1.fillText(text, x0, y0);
            }
            ctext1.stroke();
        }
        function drawresult() {
            var text = document.getElementById('node');
            text.innerHTML += "<br/>";
            text.innerHTML += "ID" + "&nbsp" + "POINT" + "<br/>";
            for (var i = 0; i < Node.length; i++) {
                text.innerHTML += "N" + (i + 1);
                text.innerHTML += "&nbsp";
                text.innerHTML += "(" + Node[i][0] + "," + Node[i][1] + ")";
                text.innerHTML += "<br/>";
            }
        function ClearCanvas() {
            ctext1.clearRect(0, 0, canvas1.width, canvas1.height);
            ctext2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
    </script>
</body>

</html>